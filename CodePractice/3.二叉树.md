# 二叉树



## 基本概念和常规操作



**二叉树节点结构：**

```c++
template<class T>
struct Node{
    T val;
    Node *left;
    Node *right;
    Node(T val, Node<T> *left= nullptr, Node<T>*right=nullptr):val(val), left(left),right(right){}
};
```

**基本问题：**

1. 用递归、非递归两种方式实现二叉树的先序、中序和后序遍历；
2. 直观打印二叉树；
3. 完成二叉树的宽度优先遍历（常见题目：求一棵二叉树的宽度）

**先序遍历：**根、左、右

**中序遍历：**左、根、右

**后序遍历：**左、右、根



**佐老哥解释：**

![image-20211230213400473](./img/binary_tree.png)

**递归序：**

每个节点都会遍历三次，形成的序列为：1，2，4，4，4，2，5，5，5，2，1，3，6，6，6，3，7，7，7，3，1

```c++
void f(Node *tree){
    if(tree == nullptr) return;
    else{
        //1
        f(tree->left);
        //2
        f(tree->right);
        //3
    }
}
```

**先序遍历：**第一次到节点打印：1，2，4，5，3，6，7

**中序遍历：**第二次到节点打印：4，2，5，1，6，3，7

**后序遍历：**第三次到节点打印：4，5，2，6，7，3，1

```c++
template<class T>
void preOrderRecur( Node<T> *tree){
    if(!tree) return ;
    cout<<tree->val<<'\t';
    preOrderRecur(tree->left);
    preOrderRecur(tree->right);
}

template<class T>
void inOrderRecur(Node<T> *tree){
    if(!tree) return ;
    inOrderRecur(tree->left);
    cout<<tree->val<<"\t";
    inOrderRecur(tree->right);
}
template<class T>
void postOrdRecur(Node<T> *tree){
    if(!tree) return ;
    postOrdRecur(tree->left);
    postOrdRecur(tree->right);
    cout<<tree->val<<"\t";
}
//非递归实现
/*
栈：在深度上递归的感觉。
*/
template<class T>
void preOrderIter(Node<T> *tree){
    stack<Node<T>*> tmp_stack;
    tmp_stack.push(tree);
    Node<T> *current;
    while (!tmp_stack.empty()){
        current = tmp_stack.top();
        cout<<current->val<<"\t";
        tmp_stack.pop();
        if(current->right) tmp_stack.push(current->right);
        if(current->left) tmp_stack.push(current->left);
    }
    //从压站顺序上来看，是根右左
}

template<class T>
void postOrderIter(Node<T> *tree){
    stack<Node<T> *> first;
    stack<Node<T> *> second;
    Node<T> *current;
    first.push(tree);
    while (!first.empty()){
        current = first.top();
        first.pop();
        if(current->left) first.push(current->left);
        if(current->right) first.push(current->right);
        second.push(current);
    }
    while (!second.empty()){
        cout<<second.top()->val<<"\t";
        second.pop();
    }
    //需要左右根，前序遍历从压站顺序上来看，是根右左，我们再反一下就是左右根，用什么反？栈！！！
}


template <class  T>
void inOrderIter(Node<T> *tree){
    // 思路：如果有左孩子，左孩子一直进栈，直到没有；然后开始弹出，弹出就打印，然后如果有右孩子，指针跑到右孩子上去，周而复始。
    stack<Node<T>*> tmp;
    Node<T> *current = tree;
    while (current || !tmp.empty()){
        if(current) {
            tmp.push(current);
            current = current->left;
        }
        else{
            current = tmp.top();
            tmp.pop();
            cout<<current->val<<"\t";
            current = current->right;
        }

    }
}
```

![image-20211230224148803](./img/inOrderIter.png)

**中序示意图：**左，根，右。（虽然永远是先左再头，但是刚好是这样遍历的）



### 1. 获取最大层数

```c++
//统计最大宽度,用哈希表记录当前层数和当前节点数；
template<class T>
int maxWidth(Node<T> *tree){
    queue<Node<T>*>my;
    unordered_map<Node<T>*, int> levelMap;
    int current_level = 1;
    int current_node = 0;
    int maxNode = 0;
    levelMap[tree] = 1;
    my.push(tree);
    Node<T>*current;
    while (!my.empty()){
        current = my.front();
        my.pop();
        int level = levelMap[current];
        if(level == current_level){
            current_node++;
        }else{
            maxNode = maxNode > current_node ? maxNode : current_node;
            current_node = 1;
            current_level++;
        }
        if(current->left){
            levelMap[current->left] = current_level + 1;
            my.push(current->left);
        }
        if(current->right){
            levelMap[current->right] = current_level + 1;
            my.push(current->right);
        }
    }
    maxNode = maxNode > current_node ? maxNode : current_node; //别忘了最后也要比较一下！
    return maxNode;
}
//不用hash table的方法记得学会！！！！

```



### 2. 如何判断一棵二叉树是否是搜索二叉树(Binary Search Tree, BST)？

**定义：**每一棵子树，左树都比它小，右树都比它大；

**做法：**中序遍历，一定是升序的(左根右)；

**关键：**思考树的特点和我们熟悉的哪种遍历规则比较相似；

```c++
//recursive method;
template<class T>
bool isBST(Node<T> *root){
    if(!root) return true;
    static preValue = INT32_MIN; //静态变量不会被再次初始化的；
    bool isLeftBst = isBST(root->left);
    if(!isLeftBst) return false;
    if(root->val <= preValue) return false;
    else preValue = root->val;
    return isBST(root->right);
}
// 递归方法2， 比较蠢。
template<class T>
bool isBinarySearchTree2(Node<T> *root){
    vector<Node<T>*> list;
    inOrderInsert(root, list);
    for(int i=1;i<list.size();i++){
        if(list[i-1]->val >= list[i]->val) return false;
    }
    return true;
}

template<class T>
void inOrderInsert(Node<T> *root, vector<Node<T>*> list){
    if(!root) return ;
    inOrderRecur(root->left);
    list.push_back(root);
    inOrderRecur(root->right);
}
// 非递归方法，还是在中序遍历上改
template<class T>
bool isBinarySearchTree3(Node<T> *root){
    if(!root) return true;
    stack<Node<T>*> tmp_stack;
    Node<T> *current = root;
    int preValue = INT32_MIN;
    while (current || !tmp_stack.empty()){
        if(current){
            tmp_stack.push(current);
            current = current->left;
        }else{
            current = tmp_stack.top();
            tmp_stack.pop();
            if(current->val <= preValue) return false;
            else preValue = current->val;
            current = current->right;
        }
    }
    return true;
}

//套路解法
/*
我要判断它是否是一个搜索树，对于每个节点为头节点的子树：
我需要向左树要：
1.它是不是个搜索树？
2.它的所有节点的最大值是多少？
我需要向右树要：
1.它是不是搜索树？
2.它的所有节点的最小值时多少？
有了这些信息：
我就能通过判断 我是不是比左边最大还大，比右边最小还小。

这时候就左右要的信息矛盾怎么办？都保留呗！
*/
template<class T>
bool isBinarySearchTree4(Node<T> *root){
    return isBinarySearchTreeNew(root).isBST;
}
struct BSTStruct{
        bool isBST;
        int max_val;
        int min_val;
        BSTStruct(bool isBST,int min_val=INT32_MAX,int max_val=INT32_MIN):isBST(isBST), min_val(min_val),max_val(max_val){}
};
template<class T>
BSTStruct isBinarySearchTreeNew(Node<T> *root){
    if(!root) return BSTStruct(true);
    BSTStruct left = isBinarySearchTreeNew(root->left);
    BSTStruct right = isBinarySearchTreeNew(root->right);
    if(!left.isBST || !right.isBST) return BSTStruct(false);
    if(root->val <= left.max_val) return BSTStruct(false);
    if(root->val >= right.min_val) return BSTStruct(false);
    int max_val = max(max(left.max_val, right.max_val), root->val);
    int min_val = min(min(left.min_val, right.min_val), root->val);
    return BSTStruct(true, min_val, max_val);
}
```

### 3. 如何判断一棵二叉树是完全二叉树？

使用层次（宽度）遍历；

* 任意节点，如果有右孩子，没有左孩子，返回false；
* 第一个条件不违规的条件下，如果遇到了第一个左右孩子不双全的情况，那么接下来左右节点都是叶节点；

```c++
template<class T>
bool isCompleteBinaryTree(Node<T> *root){
    if(!root) return true;
    queue<Node<T>*> my_queue;
    my_queue.push(root);
    Node<T> *current;
    bool isLeaf = false;
    while (!my_queue.empty()){
        current = my_queue.front();
        my_queue.pop();
        if(current->right && !current->left) return false;
        if(isLeaf && (current->left || current->right)) return false;
        if(current->left) my_queue.push(current->left);
        if(current->right) my_queue.push(current->right);
        if(!current->left || !current->right) isLeaf = true;
    }
    return true;
}
```



### 4. 如何判断一棵二叉树是否是满二叉树？

```c++
struct NodeAndHeightStruct{
    int nodes;
    int heights;
    NodeAndHeightStruct(int nodes, int heights):nodes(nodes), heights(heights){}
};

template<class T>
bool isFullBinaryTree(Node<T> *root){
    if(!root) return true;
    NodeAndHeightStruct res = isFullBinaryTreeSub(root);
    int nodes = res.nodes;
    int heights = res.heights;
    // nodes == 2^height - 1
    return nodes == ((1 << heights)-1);
}


template<class T>
NodeAndHeightStruct isFullBinaryTreeSub(Node<T> *root){
    if(!root) return NodeAndHeightStruct(0, 0);
    NodeAndHeightStruct left = isFullBinaryTreeSub(root->left);
    NodeAndHeightStruct right = isFullBinaryTreeSub(root->right);
    int nodes = left.nodes + right.nodes + 1;
    int heights = max(left.heights, right.heights) + 1;
    return NodeAndHeightStruct(nodes, heights);
}
```

### 5. 如何判断一棵二叉树是否是平衡二叉树？（二叉树题目套路）

**套路：**理清我要向左树要什么信息，向右树要什么信息，然后有了这些信息后我要怎么做；

**什么时候用套路：**就是能通过向左树要信息，右树要信息，然后结合自身节点信息把题解了的类型。（树形DP）

**定义：**每一棵子树，左树和右树的高度差，不会超过1；

如果以$x$为头节点的树是个平衡树，那么需要满足：

* 它的左子树是个平衡二叉树，它的右子树是个平衡二叉树；
* 它的左子树的高度和它的右子树的高度相差不超过1；

我们需要每次知道：以当前节点的为根节点的高度和以它为节点是不是个平衡树，需要两个信息，我们可以用一个struct来存储；

 ```c++
 
 template<class T>
 bool isBalanceTree(Node<T>*root){
     return isBalance(root).isBalance;
 }
 
 struct NewType {
         int height;
         bool isBalance;
         NewType(int height, bool isBalance):height(height), isBalance(isBalance){}
     };
 template <class T>
 NewType isBalance(Node<T> *root){
     if(!root) return NewType(0, true);
     NewType left =isBalance(root->left);
     NewType right = isBalance(root->right);
     bool balance = left.isBalance && right.isBalance && (abs(left.height - right.height)<=1);
     int height = max(left.height, right.height) + 1;
     return NewType(height, balance);
 }
 ```



### 6. 给定两个二叉树的节点node1和node2， 找到他们的最近公共祖先

前提：这两个节点一定在这棵树上。

**定义：**即node1和node2往上，第一个汇聚的点；



```c++
//找出每个节点的爹，然后node1的所有爹爹放到一个hashset中，然后遍历node2的爹爹们，到第一个在那个hashset的爹爹，就是他们共同的爹。
template<class T>
Node<T> * getCommonAncestor(Node<T> *root, Node<T> *node1, Node<T> *node2){
    unordered_map<Node<T> *, Node<T> *> fatherMap;
    fatherMap[root] = root;
    commonAncestorProcess(root, fatherMap);
    unordered_set<Node<T> *> n1;
    while (fatherMap[node1] != root){
        n1.insert(node1);
        node1 = fatherMap[node1];
    }
    n1.insert(node1);

    while (n1.find(node2) == n1.end()){
        node2 = fatherMap[node2];
    }
    return node2;
}
//注意参数要用引用拷贝，hastset是以值拷贝传参的，但是我们需要的是一个引用。
template<class T>
void commonAncestorProcess(Node<T> *root, unordered_map<Node<T>*, Node<T>*>& map){
    if(!root) return;
    map[root->left] = root;
    map[root->right] = root;
    commonAncestorProcess(root->left, map);
    commonAncestorProcess(root->right, map);
}

//方法2
/*
情况：
1）node1是node2的最低公共祖先或者node2是node1的最低公共祖先
2) 不互相为最低公共祖先，需要往上汇聚才能找到
*/
template<class T>
Node<T> * getCommonAncestor2(Node<T> *root, Node<T> *node1, Node<T> *node2){
    if(root == nullptr||root == node1 || root == node2) return root;
    Node<T> *leftCommon = getCommonAncestor2(root->left, node1, node2); //向左边要答案
    Node<T> *rightConmon = getCommonAncestor2(root->right, node1, node2);//向右边要答案
    if(leftCommon!= nullptr && rightConmon!= nullptr) return root;
    return leftCommon ? leftCommon : rightConmon;
}
```



### 7.在二叉树中找到一个节点的后继节点



```c++
struct Node{
    int val;
    Node *left;
    Node *right;
    Node *parent;
    Node(int val):val(val){}
}
```

**题目：**假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent为null。只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。**在二叉树的中序遍历的序列中，node的下一个节点叫做node的后继节点。**

**做法：**

* X有右树的时候，他的后继就是右树最左边的节点；
* X没有右树的时候，找第一个是parent的左孩子的节点。



```c++
struct NewNode{
        int val;
        NewNode *left;
        NewNode *right;
        NewNode *parent;
        NewNode(int val, NewNode * left= nullptr, NewNode *right= nullptr, NewNode *parent= nullptr):val(val), left(left), right(right),parent(parent){}
};

NewNode *getSuccessorNode(NewNode *node){
    if(!node) return nullptr;
    if(node->right) {//有右树，后继节点就是其右树的最左边；
        node = node->right;
        while(node->left) node = node->left;
        return node;
    } else{
        //没有右树，那就往上找，知道这个节点是它父亲的左孩子。
        NewNode *parent = node->parent;
        while (parent && parent->left != node){
            node = parent;
            parent = node->parent;
        }
        return parent;
    }
}

```



### 8.二叉树的序列化和反序列化

**题目：**就是内存里的一棵树如何变成字符串的形式，又如何从字符串形式变成内存里的树。



**解法：**

* 可以使用先序遍历，然后将树存储为字符串；



```c++
//用先序遍历
template<class T>
string serialByPre(Node<T> *root){
    //根左右
    if(!root) return "#_";
    string res = to_string(root->val) +"_";
    res += serialByPre(root->left);
    res += serialByPre(root->right);
    return res;
}
//字符串split函数，好好学学。
void split(const string &s, vector<string> &tokens, const string & delimiters=" "){
    string::size_type lastPos = s.find_first_not_of(delimiters, 0);
    string::size_type pos = s.find_first_of(delimiters, lastPos);
    while (string::npos != pos || string::npos != lastPos){
        tokens.push_back(s.substr(lastPos, pos - lastPos));
        lastPos = s.find_first_not_of(delimiters, pos);
        pos = s.find_first_of(delimiters, lastPos);
    }
}
template<class T>
Node<T> *reconPreOrder(queue<string> &tmpQueue){
    string val = tmpQueue.front();
    tmpQueue.pop();
    if(val == "#") return nullptr;
    Node<T>* head = new Node<T> (atoi(val.c_str()));
    head->left = reconPreOrder<T>(tmpQueue);
    head->right = reconPreOrder<T>(tmpQueue);
    return head;
}

template<class T>
Node<T>* reconByPreString(string preStr){
    vector<string> values;
    split(preStr, values, "_");
    queue<string> tmpQueue;
    for(auto s: values) tmpQueue.push(s);
    Node<T>*res = reconPreOrder<T>(tmpQueue);
    return res;
}

//自己写的函数，判断是不是一模一样的树
template<class T>
bool saveTree(Node<T> *root1, Node<T> *root2){
    if(!root1 && root2 || root1 && !root2) return false;
    if(!root1 && !root2) return true;
    if(root1->val != root2->val) return false;
    return saveTree(root1->left, root2->left) && saveTree(root1->right, root2->right);
}
```



### 9.纸对折痕迹打印

纸条对折一次，中间产生凹痕，再对折从上到下会产生“凹 凹 凸”的痕迹，对折$N$次后产生的折痕从上到下是什么？



```c++
void printProcess(int i, int N, bool down){
    if(i > N) return;
    printProcess(i+1, N, true);
    cout<<(down ? "凹":"凸")<<"\t";
    printProcess(i+1, N, false);
 }
void printAllFolds(int N){
    printProcess(1, N, true);
}

```



## Leetcode 习题



#### 96. Unique Binary Search Trees[Medium]

![image-20220112142339047](./img/leetcode96_question.png)



**核心思想：**通过个例归纳出公式，进行递归。（子问题重复，采用DP）

![image-20220112142024328](/Users/mahongying/CLionProjects/LeetCodeProblem/CodePractice/img/leetcode96.png)

```c++
class Solution {
public:
    int numTrees(int n) {
        if(n <= 1) return 1;
        int ans = 0;
        for(int i = 1; i <= n; i++) 
            ans += numTrees(i-1) * numTrees(n-i);
        return ans;
    }
};

//子问题重复，进行DP
class Solution {
public:
    int numTrees(int n) {
        int res = 0;
        vector<int> dp(20);
        dp[1] = 1;
        dp[0] = 1;
        for(int j=2;j<=n;j++){
            for(int i=1;i<=j;i++){
                dp[j] += dp[i-1] * dp[j - i];
        	}     
    	}
      return dp[n];  
    }
};
```

#### 98.Validate Binary Search Tree[Medium]

**题目：**Given the `root` of a binary tree, *determine if it is a valid binary search tree (BST)*.

A **valid BST** is defined as follows:

- The left subtree of a node contains only nodes with keys **less than** the node's key.
- The right subtree of a node contains only nodes with keys **greater than** the node's key.
- Both the left and right subtrees must also be binary search trees.

```c++
.//中序遍历，注意这个prev初始化的处理方式，可以用空指针。
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> my;
        TreeNode * current = root;
        TreeNode *prev = nullptr;
        while(current || !my.empty()){
            if(current){
                my.push(current);
                current = current->left;
            }else{
                current = my.top();
                if(prev && current->val <= prev->val) return false;
                prev = current;
                my.pop();
                current = current->right;
            }
        }
        return true;
    }
};

//中序遍历递归，左树需要知道max，右树需要知道min。可以按照套路定义结构，也可以用引用记录。
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return help(root, LONG_MIN, LONG_MAX);
    }
 
    bool help(TreeNode* root, long min, long max){
        if(!root)   return true;
        if(root->val <= min || root->val >= max)  return false;
        return help(root->left, min, root->val) && help(root->right, root->val, max);
    }
};
```



#### 95.Unique Binary Search Trees II[Medium]

**题目：**Given an integer `n`, return *all the structurally unique **BST'**s (binary search trees), which has exactly* `n` *nodes of unique values from* `1` *to* `n`. Return the answer in **any order**.

![image-20220112145812131](./img/leetcode95.png)

```c++
//自己写的，以每个节点为头节点，进行递归。【最高赞也是这么写的】
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        return generate(1, n);
    }
    vector<TreeNode *> generate(int left, int right){
        if(left == right) return vector<TreeNode *>{new TreeNode(left)};
        if(left > right) return vector<TreeNode *>{nullptr};
         vector<TreeNode *> res;
        for(int i=left; i<=right;i++){
            vector<TreeNode*> leftTree = generate(left, i-1);
            vector<TreeNode*> rightTree = generate(i+1, right);
            for(int j=0;j<leftTree.size();j++){
                for(int k=0;k<rightTree.size();k++){
                    TreeNode *root = new TreeNode(i, leftTree[j], rightTree[k]);
                    res.push_back(root);
                }
            }  
        }
        return res; 
    }
};


//基于DP的方法。
vector<TreeNode*> generateTrees(int n) {
        vector<TreeNode *> res;
        if(n>0)
            res.push_back(nullptr);
        for(int i=1;i<=n;i++) {
            vector<TreeNode *> temp;
            int sz=res.size();
            for(int j=0;j<sz;j++) {
            	TreeNode *oldT=res[j],*subr=oldT;
				TreeNode *newTree=new TreeNode(i);
				newTree->left=oldT;
                res[j]=newTree;
                TreeNode tnode(i);
				while(subr) {
                    TreeNode *rchild=subr->right,*newnode=&tnode;
                    newnode->left=rchild;
                    subr->right=newnode;
                    res.push_back(CloneTree(oldT));
                    subr->right=rchild;
                    subr=subr->right;
				}
            }
        }
		return res;
    }
    TreeNode *CloneTree(TreeNode *root) {
        if(!root)
            return nullptr;
        TreeNode *newR=new TreeNode(root->val);
        newR->left=CloneTree(root->left);
        newR->right=CloneTree(root->right);
        return newR;
    }
```

**DP：** the  basic idea is that we can construct the result of $n$ node tree just from the result of n-1 node tree.
Here's how we do it: only 2 conditions: 

* The $n$-th node is the new root, so `newroot->left = oldroot;`
* the $n$-th node is not root, we traverse the old tree, every time the node in the old tree has a right child, we can perform: `old node->right = nth node, nth node ->left = right child;` and when we reach the end of the tree, don't forget we can also add the $n$-th node here.
  One thing to notice is that every time we push a TreeNode in our result, I push the clone version of the root, and I recover what I do to the old node immediately. This is because you may use the old tree for several times.