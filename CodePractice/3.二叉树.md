# 二叉树



## 基本概念和常规操作



**二叉树节点结构：**

```c++
template<class T>
struct Node{
    T val;
    Node *left;
    Node *right;
    Node(T val, Node<T> *left= nullptr, Node<T>*right=nullptr):val(val), left(left),right(right){}
};
```

**基本问题：**

1. 用递归、非递归两种方式实现二叉树的先序、中序和后序遍历；
2. 直观打印二叉树；
3. 完成二叉树的宽度优先遍历（常见题目：求一棵二叉树的宽度）

**先序遍历：**根、左、右

**中序遍历：**左、根、右

**后序遍历：**左、右、根



**佐老哥解释：**

![image-20211230213400473](./img/binary_tree.png)

**递归序：**

每个节点都会遍历三次，形成的序列为：1，2，4，4，4，2，5，5，5，2，1，3，6，6，6，3，7，7，7，3，1

```c++
void f(Node *tree){
    if(tree == nullptr) return;
    else{
        //1
        f(tree->left);
        //2
        f(tree->right);
        //3
    }
}
```

**先序遍历：**第一次到节点打印：1，2，4，5，3，6，7

**中序遍历：**第二次到节点打印：4，2，5，1，6，3，7

**后序遍历：**第三次到节点打印：4，5，2，6，7，3，1

```c++
template<class T>
void preOrderRecur( Node<T> *tree){
    if(!tree) return ;
    cout<<tree->val<<'\t';
    preOrderRecur(tree->left);
    preOrderRecur(tree->right);
}

template<class T>
void inOrderRecur(Node<T> *tree){
    if(!tree) return ;
    inOrderRecur(tree->left);
    cout<<tree->val<<"\t";
    inOrderRecur(tree->right);
}
template<class T>
void postOrdRecur(Node<T> *tree){
    if(!tree) return ;
    postOrdRecur(tree->left);
    postOrdRecur(tree->right);
    cout<<tree->val<<"\t";
}
//非递归实现
/*
栈：在深度上递归的感觉。
*/
template<class T>
void preOrderIter(Node<T> *tree){
    stack<Node<T>*> tmp_stack;
    tmp_stack.push(tree);
    Node<T> *current;
    while (!tmp_stack.empty()){
        current = tmp_stack.top();
        cout<<current->val<<"\t";
        tmp_stack.pop();
        if(current->right) tmp_stack.push(current->right);
        if(current->left) tmp_stack.push(current->left);
    }
    //从压站顺序上来看，是根右左
}

template<class T>
void postOrderIter(Node<T> *tree){
    stack<Node<T> *> first;
    stack<Node<T> *> second;
    Node<T> *current;
    first.push(tree);
    while (!first.empty()){
        current = first.top();
        first.pop();
        if(current->left) first.push(current->left);
        if(current->right) first.push(current->right);
        second.push(current);
    }
    while (!second.empty()){
        cout<<second.top()->val<<"\t";
        second.pop();
    }
    //需要左右根，前序遍历从压站顺序上来看，是根右左，我们再反一下就是左右根，用什么反？栈！！！
}


template <class  T>
void inOrderIter(Node<T> *tree){
    // 思路：如果有左孩子，左孩子一直进栈，直到没有；然后开始弹出，弹出就打印，然后如果有右孩子，指针跑到右孩子上去，周而复始。
    stack<Node<T>*> tmp;
    Node<T> *current = tree;
    while (current || !tmp.empty()){
        if(current) {
            tmp.push(current);
            current = current->left;
        }
        else{
            current = tmp.top();
            tmp.pop();
            cout<<current->val<<"\t";
            current = current->right;
        }

    }
}
```

![image-20211230224148803](./img/inOrderIter.png)

**中序示意图：**左，根，右。（虽然永远是先左再头，但是刚好是这样遍历的）



### 1. 获取最大层数

```c++
//统计最大宽度,用哈希表记录当前层数和当前节点数；
template<class T>
int maxWidth(Node<T> *tree){
    queue<Node<T>*>my;
    unordered_map<Node<T>*, int> levelMap;
    int current_level = 1;
    int current_node = 0;
    int maxNode = 0;
    levelMap[tree] = 1;
    my.push(tree);
    Node<T>*current;
    while (!my.empty()){
        current = my.front();
        my.pop();
        int level = levelMap[current];
        if(level == current_level){
            current_node++;
        }else{
            maxNode = maxNode > current_node ? maxNode : current_node;
            current_node = 1;
            current_level++;
        }
        if(current->left){
            levelMap[current->left] = current_level + 1;
            my.push(current->left);
        }
        if(current->right){
            levelMap[current->right] = current_level + 1;
            my.push(current->right);
        }
    }
    maxNode = maxNode > current_node ? maxNode : current_node; //别忘了最后也要比较一下！
    return maxNode;
}
//不用hash table的方法记得学会！！！！

```



### 2. 如何判断一棵二叉树是否是搜索二叉树(Binary Search Tree, BST)？

**定义：**每一棵子树，左树都比它小，右树都比它大；

**做法：**中序遍历，一定是升序的(左根右)；

**关键：**思考树的特点和我们熟悉的哪种遍历规则比较相似；

```c++
//recursive method;
template<class T>
bool isBST(Node<T> *root){
    if(!root) return true;
    static preValue = INT32_MIN; //静态变量不会被再次初始化的；
    bool isLeftBst = isBST(root->left);
    if(!isLeftBst) return false;
    if(root->val <= preValue) return false;
    else preValue = root->val;
    return isBST(root->right);
}
// 递归方法2， 比较蠢。
template<class T>
bool isBinarySearchTree2(Node<T> *root){
    vector<Node<T>*> list;
    inOrderInsert(root, list);
    for(int i=1;i<list.size();i++){
        if(list[i-1]->val >= list[i]->val) return false;
    }
    return true;
}

template<class T>
void inOrderInsert(Node<T> *root, vector<Node<T>*> list){
    if(!root) return ;
    inOrderRecur(root->left);
    list.push_back(root);
    inOrderRecur(root->right);
}
// 非递归方法，还是在中序遍历上改
template<class T>
bool isBinarySearchTree3(Node<T> *root){
    if(!root) return true;
    stack<Node<T>*> tmp_stack;
    Node<T> *current = root;
    int preValue = INT32_MIN;
    while (current || !tmp_stack.empty()){
        if(current){
            tmp_stack.push(current);
            current = current->left;
        }else{
            current = tmp_stack.top();
            tmp_stack.pop();
            if(current->val <= preValue) return false;
            else preValue = current->val;
            current = current->right;
        }
    }
    return true;
}

//套路解法
/*
我要判断它是否是一个搜索树，对于每个节点为头节点的子树：
我需要向左树要：
1.它是不是个搜索树？
2.它的所有节点的最大值是多少？
我需要向右树要：
1.它是不是搜索树？
2.它的所有节点的最小值时多少？
有了这些信息：
我就能通过判断 我是不是比左边最大还大，比右边最小还小。

这时候就左右要的信息矛盾怎么办？都保留呗！
*/
template<class T>
bool isBinarySearchTree4(Node<T> *root){
    return isBinarySearchTreeNew(root).isBST;
}
struct BSTStruct{
        bool isBST;
        int max_val;
        int min_val;
        BSTStruct(bool isBST,int min_val=INT32_MAX,int max_val=INT32_MIN):isBST(isBST), min_val(min_val),max_val(max_val){}
};
template<class T>
BSTStruct isBinarySearchTreeNew(Node<T> *root){
    if(!root) return BSTStruct(true);
    BSTStruct left = isBinarySearchTreeNew(root->left);
    BSTStruct right = isBinarySearchTreeNew(root->right);
    if(!left.isBST || !right.isBST) return BSTStruct(false);
    if(root->val <= left.max_val) return BSTStruct(false);
    if(root->val >= right.min_val) return BSTStruct(false);
    int max_val = max(max(left.max_val, right.max_val), root->val);
    int min_val = min(min(left.min_val, right.min_val), root->val);
    return BSTStruct(true, min_val, max_val);
}
```

### 3. 如何判断一棵二叉树是完全二叉树？

使用层次（宽度）遍历；

* 任意节点，如果有右孩子，没有左孩子，返回false；
* 第一个条件不违规的条件下，如果遇到了第一个左右孩子不双全的情况，那么接下来左右节点都是叶节点；

```c++
template<class T>
bool isCompleteBinaryTree(Node<T> *root){
    if(!root) return true;
    queue<Node<T>*> my_queue;
    my_queue.push(root);
    Node<T> *current;
    bool isLeaf = false;
    while (!my_queue.empty()){
        current = my_queue.front();
        my_queue.pop();
        if(current->right && !current->left) return false;
        if(isLeaf && (current->left || current->right)) return false;
        if(current->left) my_queue.push(current->left);
        if(current->right) my_queue.push(current->right);
        if(!current->left || !current->right) isLeaf = true;
    }
    return true;
}
```



### 4. 如何判断一棵二叉树是否是满二叉树？

```c++
struct NodeAndHeightStruct{
    int nodes;
    int heights;
    NodeAndHeightStruct(int nodes, int heights):nodes(nodes), heights(heights){}
};

template<class T>
bool isFullBinaryTree(Node<T> *root){
    if(!root) return true;
    NodeAndHeightStruct res = isFullBinaryTreeSub(root);
    int nodes = res.nodes;
    int heights = res.heights;
    // nodes == 2^height - 1
    return nodes == ((1 << heights)-1);
}


template<class T>
NodeAndHeightStruct isFullBinaryTreeSub(Node<T> *root){
    if(!root) return NodeAndHeightStruct(0, 0);
    NodeAndHeightStruct left = isFullBinaryTreeSub(root->left);
    NodeAndHeightStruct right = isFullBinaryTreeSub(root->right);
    int nodes = left.nodes + right.nodes + 1;
    int heights = max(left.heights, right.heights) + 1;
    return NodeAndHeightStruct(nodes, heights);
}
```

### 5. 如何判断一棵二叉树是否是平衡二叉树？（二叉树题目套路）

**套路：**理清我要向左树要什么信息，向右树要什么信息，然后有了这些信息后我要怎么做；

**什么时候用套路：**就是能通过向左树要信息，右树要信息，然后结合自身节点信息把题解了的类型。（树形DP）

**定义：**每一棵子树，左树和右树的高度差，不会超过1；

如果以$x$为头节点的树是个平衡树，那么需要满足：

* 它的左子树是个平衡二叉树，它的右子树是个平衡二叉树；
* 它的左子树的高度和它的右子树的高度相差不超过1；

我们需要每次知道：以当前节点的为根节点的高度和以它为节点是不是个平衡树，需要两个信息，我们可以用一个struct来存储；

 ```c++
 
 template<class T>
 bool isBalanceTree(Node<T>*root){
     return isBalance(root).isBalance;
 }
 
 struct NewType {
         int height;
         bool isBalance;
         NewType(int height, bool isBalance):height(height), isBalance(isBalance){}
     };
 template <class T>
 NewType isBalance(Node<T> *root){
     if(!root) return NewType(0, true);
     NewType left =isBalance(root->left);
     NewType right = isBalance(root->right);
     bool balance = left.isBalance && right.isBalance && (abs(left.height - right.height)<=1);
     int height = max(left.height, right.height) + 1;
     return NewType(height, balance);
 }
 ```



### 6. 给定两个二叉树的节点node1和node2， 找到他们的最近公共祖先

前提：这两个节点一定在这棵树上。

**定义：**即node1和node2往上，第一个汇聚的点；



```c++
//找出每个节点的爹，然后node1的所有爹爹放到一个hashset中，然后遍历node2的爹爹们，到第一个在那个hashset的爹爹，就是他们共同的爹。
template<class T>
Node<T> * getCommonAncestor(Node<T> *root, Node<T> *node1, Node<T> *node2){
    unordered_map<Node<T> *, Node<T> *> fatherMap;
    fatherMap[root] = root;
    commonAncestorProcess(root, fatherMap);
    unordered_set<Node<T> *> n1;
    while (fatherMap[node1] != root){
        n1.insert(node1);
        node1 = fatherMap[node1];
    }
    n1.insert(node1);

    while (n1.find(node2) == n1.end()){
        node2 = fatherMap[node2];
    }
    return node2;
}
//注意参数要用引用拷贝，hastset是以值拷贝传参的，但是我们需要的是一个引用。
template<class T>
void commonAncestorProcess(Node<T> *root, unordered_map<Node<T>*, Node<T>*>& map){
    if(!root) return;
    map[root->left] = root;
    map[root->right] = root;
    commonAncestorProcess(root->left, map);
    commonAncestorProcess(root->right, map);
}

//方法2
/*
情况：
1）node1是node2的最低公共祖先或者node2是node1的最低公共祖先
2) 不互相为最低公共祖先，需要往上汇聚才能找到
*/
template<class T>
Node<T> * getCommonAncestor2(Node<T> *root, Node<T> *node1, Node<T> *node2){
    if(root == nullptr||root == node1 || root == node2) return root;
    Node<T> *leftCommon = getCommonAncestor2(root->left, node1, node2); //向左边要答案
    Node<T> *rightConmon = getCommonAncestor2(root->right, node1, node2);//向右边要答案
    if(leftCommon!= nullptr && rightConmon!= nullptr) return root;
    return leftCommon ? leftCommon : rightConmon;
}
```



### 7.在二叉树中找到一个节点的后继节点



```c++
struct Node{
    int val;
    Node *left;
    Node *right;
    Node *parent;
    Node(int val):val(val){}
}
```

**题目：**假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent为null。只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。**在二叉树的中序遍历的序列中，node的下一个节点叫做node的后继节点。**

**做法：**

* X有右树的时候，他的后继就是右树最左边的节点；
* X没有右树的时候，找第一个是parent的左孩子的节点。



```c++
struct NewNode{
        int val;
        NewNode *left;
        NewNode *right;
        NewNode *parent;
        NewNode(int val, NewNode * left= nullptr, NewNode *right= nullptr, NewNode *parent= nullptr):val(val), left(left), right(right),parent(parent){}
};

NewNode *getSuccessorNode(NewNode *node){
    if(!node) return nullptr;
    if(node->right) {//有右树，后继节点就是其右树的最左边；
        node = node->right;
        while(node->left) node = node->left;
        return node;
    } else{
        //没有右树，那就往上找，知道这个节点是它父亲的左孩子。
        NewNode *parent = node->parent;
        while (parent && parent->left != node){
            node = parent;
            parent = node->parent;
        }
        return parent;
    }
}

```



### 8.二叉树的序列化和反序列化

**题目：**就是内存里的一棵树如何变成字符串的形式，又如何从字符串形式变成内存里的树。



**解法：**

* 可以使用先序遍历，然后将树存储为字符串；



```c++
//用先序遍历
template<class T>
string serialByPre(Node<T> *root){
    //根左右
    if(!root) return "#_";
    string res = to_string(root->val) +"_";
    res += serialByPre(root->left);
    res += serialByPre(root->right);
    return res;
}
//字符串split函数，好好学学。
void split(const string &s, vector<string> &tokens, const string & delimiters=" "){
    string::size_type lastPos = s.find_first_not_of(delimiters, 0);
    string::size_type pos = s.find_first_of(delimiters, lastPos);
    while (string::npos != pos || string::npos != lastPos){
        tokens.push_back(s.substr(lastPos, pos - lastPos));
        lastPos = s.find_first_not_of(delimiters, pos);
        pos = s.find_first_of(delimiters, lastPos);
    }
}
template<class T>
Node<T> *reconPreOrder(queue<string> &tmpQueue){
    string val = tmpQueue.front();
    tmpQueue.pop();
    if(val == "#") return nullptr;
    Node<T>* head = new Node<T> (atoi(val.c_str()));
    head->left = reconPreOrder<T>(tmpQueue);
    head->right = reconPreOrder<T>(tmpQueue);
    return head;
}

template<class T>
Node<T>* reconByPreString(string preStr){
    vector<string> values;
    split(preStr, values, "_");
    queue<string> tmpQueue;
    for(auto s: values) tmpQueue.push(s);
    Node<T>*res = reconPreOrder<T>(tmpQueue);
    return res;
}

//自己写的函数，判断是不是一模一样的树
template<class T>
bool saveTree(Node<T> *root1, Node<T> *root2){
    if(!root1 && root2 || root1 && !root2) return false;
    if(!root1 && !root2) return true;
    if(root1->val != root2->val) return false;
    return saveTree(root1->left, root2->left) && saveTree(root1->right, root2->right);
}
```



### 9.纸对折痕迹打印

纸条对折一次，中间产生凹痕，再对折从上到下会产生“凹 凹 凸”的痕迹，对折$N$次后产生的折痕从上到下是什么？



```c++
void printProcess(int i, int N, bool down){
    if(i > N) return;
    printProcess(i+1, N, true);
    cout<<(down ? "凹":"凸")<<"\t";
    printProcess(i+1, N, false);
 }
void printAllFolds(int N){
    printProcess(1, N, true);
}

```



## Leetcode 习题



#### 96. Unique Binary Search Trees[Medium]

![image-20220112142339047](./img/leetcode96_question.png)



**核心思想：**通过个例归纳出公式，进行递归。（子问题重复，采用DP）

![image-20220112142024328](./img/leetcode96.png)

```c++
class Solution {
public:
    int numTrees(int n) {
        if(n <= 1) return 1;
        int ans = 0;
        for(int i = 1; i <= n; i++) 
            ans += numTrees(i-1) * numTrees(n-i);
        return ans;
    }
};

//子问题重复，进行DP
class Solution {
public:
    int numTrees(int n) {
        int res = 0;
        vector<int> dp(20);
        dp[1] = 1;
        dp[0] = 1;
        for(int j=2;j<=n;j++){
            for(int i=1;i<=j;i++){
                dp[j] += dp[i-1] * dp[j - i];
        	}     
    	}
      return dp[n];  
    }
};
```

#### 98. Validate Binary Search Tree[Medium]

**题目：**Given the `root` of a binary tree, *determine if it is a valid binary search tree (BST)*.

A **valid BST** is defined as follows:

- The left subtree of a node contains only nodes with keys **less than** the node's key.
- The right subtree of a node contains only nodes with keys **greater than** the node's key.
- Both the left and right subtrees must also be binary search trees.

```c++
.//中序遍历，注意这个prev初始化的处理方式，可以用空指针。
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> my;
        TreeNode * current = root;
        TreeNode *prev = nullptr;
        while(current || !my.empty()){
            if(current){
                my.push(current);
                current = current->left;
            }else{
                current = my.top();
                if(prev && current->val <= prev->val) return false;
                prev = current;
                my.pop();
                current = current->right;
            }
        }
        return true;
    }
};

//中序遍历递归，左树需要知道max，右树需要知道min。可以按照套路定义结构，也可以用引用记录。
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return help(root, LONG_MIN, LONG_MAX);
    }
 
    bool help(TreeNode* root, long min, long max){
        if(!root)   return true;
        if(root->val <= min || root->val >= max)  return false;
        return help(root->left, min, root->val) && help(root->right, root->val, max);
    }
};
```



#### 95.Unique Binary Search Trees II[Medium]

**题目：**Given an integer `n`, return *all the structurally unique **BST'**s (binary search trees), which has exactly* `n` *nodes of unique values from* `1` *to* `n`. Return the answer in **any order**.

![image-20220112145812131](./img/leetcode95.png)

```c++
//自己写的，以每个节点为头节点，进行递归。【最高赞也是这么写的】
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        return generate(1, n);
    }
    vector<TreeNode *> generate(int left, int right){
        if(left == right) return vector<TreeNode *>{new TreeNode(left)};
        if(left > right) return vector<TreeNode *>{nullptr};
         vector<TreeNode *> res;
        for(int i=left; i<=right;i++){
            vector<TreeNode*> leftTree = generate(left, i-1);
            vector<TreeNode*> rightTree = generate(i+1, right);
            for(int j=0;j<leftTree.size();j++){
                for(int k=0;k<rightTree.size();k++){
                    TreeNode *root = new TreeNode(i, leftTree[j], rightTree[k]);
                    res.push_back(root);
                }
            }  
        }
        return res; 
    }
};


//基于DP的方法。
vector<TreeNode*> generateTrees(int n) {
        vector<TreeNode *> res;
        if(n>0)
            res.push_back(nullptr);
        for(int i=1;i<=n;i++) {
            vector<TreeNode *> temp;
            int sz=res.size();
            for(int j=0;j<sz;j++) {
            	TreeNode *oldT=res[j],*subr=oldT;
				TreeNode *newTree=new TreeNode(i);
				newTree->left=oldT;
                res[j]=newTree;
                TreeNode tnode(i);
				while(subr) {
                    TreeNode *rchild=subr->right,*newnode=&tnode;
                    newnode->left=rchild;
                    subr->right=newnode;
                    res.push_back(CloneTree(oldT));
                    subr->right=rchild;
                    subr=subr->right;
				}
            }
        }
		return res;
    }
    TreeNode *CloneTree(TreeNode *root) {
        if(!root)
            return nullptr;
        TreeNode *newR=new TreeNode(root->val);
        newR->left=CloneTree(root->left);
        newR->right=CloneTree(root->right);
        return newR;
    }
```

**DP：** the  basic idea is that we can construct the result of $n$ node tree just from the result of n-1 node tree.
Here's how we do it: only 2 conditions: 

* The $n$-th node is the new root, so `newroot->left = oldroot;`
* the $n$-th node is not root, we traverse the old tree, every time the node in the old tree has a right child, we can perform: `old node->right = nth node, nth node ->left = right child;` and when we reach the end of the tree, don't forget we can also add the $n$-th node here.
  One thing to notice is that every time we push a TreeNode in our result, I push the clone version of the root, and I recover what I do to the old node immediately. This is because you may use the old tree for several times.

#### 96. Flatten Binary Tree to Linked List[Medium]

Given the `root` of a binary tree, flatten the tree into a "linked list":

- The "linked list" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`.

- The "linked list" should be in the same order as a [**pre-order** **traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR) of the binary tree.

  ![image-20220113104713762](./img/leetcode114.png)

```c++
//很直接的思路：左边展平接到root右边，右边展平再续上。
class Solution {
public:
    void flatten(TreeNode* root) {
        if(!root) return;
        TreeNode *left = root->left;
        TreeNode *right = root->right;
        root->left = nullptr;
        flatten(left);
        flatten(right);
        root->right = left;
        TreeNode *current = root;
        while(current->right) current = current->right;
        current->right = right;
    }
};
//时间复杂度：master 公式：T(N)=2T(N/2) + O(N); T(N)=N log N
//空间复杂度：O（N）

//牛逼的做法我没看懂
class Solution {
public:
    TreeNode *prev=nullptr;
    void flatten(TreeNode* root) {
        if(!root) return;
        flatten(root->right);
        flatten(root->left);
        root->right = prev;
        root->left = nullptr;
        prev = root;
    }
};
```

#### 116. Populating Next Right Pointers in Each Node[Medium]

You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

 

**Example 1:**

![img](img/leetcode116.png)

```markdown
Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```

```c++
//关键点，用nullptr可以在queue中标记深度信息；时间和空间复杂度都是O(N)
class Solution {
public:
    Node* connect(Node *root) {
        if (!root) return root; //Edge Case
        queue<Node*> q;
        //Trick: Push nullptr to maintain depth information
        q.push(root);
        q.push(nullptr);
        Node* current;
        while(!q.empty()){
            current = q.front();
            q.pop();
            if (current==nullptr) {
                if (q.size() > 0) q.push(nullptr);
            }
            else{
                current->next = q.front();
                if(current->left!=nullptr) q.push(current->left);
                if(current->right!=nullptr) q.push(current->right);
            }
        }
        return root;
    } 
};
//时间O(N),空间：O(1);思路很清晰；
void connect(TreeLinkNode *root) {
        TreeLinkNode* level_start = root;
        while(level_start!=NULL)
        {
            //curr is the first node in that level
            TreeLinkNode* curr = level_start;
            //Keep going to the right in that level
            while(curr!=NULL)
            {
                if(curr->left!=NULL) curr->left->next=curr->right;
                if(curr->right!=NULL && curr->next!=NULL) curr->right->next=curr->next->left;
                curr = curr->next;
            }
            level_start=level_start->left;
        }
        
    }
//递归版本
class Solution {
public:
    Node* connect(Node *root) {
        if (!root) return root; //Edge Case
        if(root->left) root->left->next = root->right;
        if(root->right && root->next) root->right->next = root->next->left;
        connect(root->left);
        connect(root->right);
        return root; 
    } 
};
```







#### 105. Construct Binary Tree from Preorder and Inorder Traversal[Medium]

Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return *the binary tree*.

 

**Example 1:**

![img](img/leetcode105.jpg)

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

```c++
//用先序遍历确定头节点，然后用中序遍历的结果确定左右子树两部分所包含的节点数目，并递归构建树。
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return buildTreeHelper(preorder, inorder, 0, 0, inorder.size()-1);
        
    }
    
    TreeNode *buildTreeHelper(vector<int>& preorder, vector<int>& inorder, int preStart, int inStart, int inEnd){
        if(inEnd < inStart || preStart > preorder.size()-1) return nullptr;
        TreeNode *root = new TreeNode(preorder[preStart]);
        int index=0;
        for(int i=inStart; i<=inEnd; i++){
            if(root->val == inorder[i]){
                index = i;
                break;
            }
        }
        root->left = buildTreeHelper(preorder, inorder, preStart+1, inStart, index-1);
        root->right = buildTreeHelper(preorder, inorder, preStart + index-inStart + 1,  index + 1, inEnd);
        return root;
    }
};
```







#### 106. Construct Binary Tree from Inorder and Postorder Traversal[Medium]

Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return *the binary tree*.

 

**Example 1:**

![img](img/leetcode106.jpg)

```
Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]
```

**Example 2:**

```
Input: inorder = [-1], postorder = [-1]
Output: [-1]
```



```c++
//我的解法，后续遍历最后一个节点为头节点。然后划分哪些是左子树上的点，哪些是右子树上的点，同时记录头节点；
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return build(inorder, postorder, postorder.size()-1, 0, inorder.size()-1);
        
    }
    
    TreeNode *build(vector<int>& inorder, vector<int>& postorder, int root_index, int inStart, int inEnd){
        if(inStart > inEnd || root_index < 0) return nullptr;
        if(inStart == inEnd) return new TreeNode(postorder[root_index]);
        TreeNode *root = new TreeNode(postorder[root_index]);
        int index;
        for(int i=0;i<inorder.size();i++)
            if(inorder[i] == root->val)
                index = i;
        root->left = build(inorder, postorder, root_index- inEnd + index-1, inStart, index-1);
        root->right = build(inorder, postorder, root_index-1, index + 1, inEnd);
        return root;
    }
};
```

