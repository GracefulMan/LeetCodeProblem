# 知识点总结

## 位运算

### 异或运算
相同为0， 不同为1；可以理解为无进位相加;
**性质:**

* `0^a=a, a^a=0, b^a^a=b`
* 满足交换律和结合律，即一批数异或的结果和异或的数的先后顺序无关；


### 相关题目

```c++
1. 交换两个数a, b
{
	a = a^b;
	b = a^b; // b = (a^b)^b = a;
	a = a^b; // a = (a^b)^a = b;
}

2. 一堆数，只有一个只出现了一次，其他都出现了两次，找出这个数;

int find(int *arr, int n){
    int res=0;//0和任何数异或为本身
    for(int i=0;i<n;i++){
        res ^= arr[i]; // 交换律，同时相同异或为0，0与其他数异或为那个数
    	}
    return res;
}

3. 一堆数，只有两个数各自只出现了一次，其他都出现了两次，找出这个数;

void find(int *arr, int n){
	int res = 0;
	for(int i=0;i<n;i++){
		res ^= arr[i]; // res = a^b
	}
	right_one = (~res + 1) & res;// 找到最右侧的第一个1，将所有数分为两类;
	only_one = 0;
	for(int i=0;i<n;i++){
		if((right_one & arr[i]) !=0){ #提取出那个位置是不是1的数，这些数其中一个是a(b)，其他必然成对；
			only_one^=arr[i];
			}
	}
	int ans1 = only_one;
	int ans2 = only_one ^ res;
}
```

## 排序算法

### 插入排序
**核心思想：**从左到右，每次找到最小放到最左边；

```c++
int swap(int arr, int i, int j){
	arr[i] = arr[i] ^ arr[j];
	arr[j] = arr[i] ^ arr[j];
	arr[i] = arr[i] ^ arr[j];
}

void insertSort(int *arr, int n){
	for(int i=0;i<n;i++){
		for(int j=i+1;j<n;j++){
			if(a[i] > a[j]) swap(a, i, j);
		}
	}
}
```


## 递归思想

**Master公式:**$T(N)=a * T(\frac{N}{b})+O(N^d)$, N为数据量，N/b表示子问题的数据量， a表示子问题的调用次数，后面部分表示除了调用子问题之外，时间复杂度是多少；
求解得:

* $log_b a<d$,复杂度为：$O(N^d)$
* $log_b a>d$,复杂度为：$O(N^{log_ba})$
* $log_b a=d$, 复杂度为: $N^d*log N$

```c++
1. 求数组元素的最大值，用递归实现;

int getMaxValue(int *arr, int left, int right){
	if(left == right) return arr[left];
	int mid = left + ((right-left)>>1);
	int leftMax = getMaxValue(arr, left, mid);
	int rightMax = getMaxValue(arr, mid+1, right);
	return leftMax > rightMax ? leftMax : rightMax;
}
```
采用Master公式分析其复杂度:
a=2, b=2, d=0,O(N^d)=O(1);得出: $T(N)=2 * T(N/2) + O(1)$. 复杂度为:$O(N)$

```c++
//2. 归并排序
void merge(int *arr, int left, int mid, int right){
    int *res = new int [right - left + 1];
    int p0=left, p1=mid+1, i=0;
    while (p0 <= mid && p1 <= right){
        res[i++] = arr[p0] < arr[p1] ? arr[p0++] : arr[p1++];
    }
    while (p0 <= mid)
        res[i++] = arr[p0++];
    while (p1 <=right)
        res[i++] = arr[p1++];
    for(int j=0;j<right - left + 1; j++){
        arr[j + left] = res[j];
    }
    delete [] res;
}
void mergeSort(int *arr, int left, int right){
    if(left == right) return;
    else{
        int mid = left + ((right - left)>>1);
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}
```
采用Master公式分析其复杂度:
a=2, b=2, d=1,O(N^d)=O(N);得出: $T(N)=2 * T(N/2) + O(N)$. 复杂度为:$N^d log N=N log N$.

